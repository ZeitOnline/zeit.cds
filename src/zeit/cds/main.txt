=======================================================
Exporting and importing zeit.cms files to an FTP server
=======================================================

Exporting
---------

zeit.cms exports files to a ``gocept.filestore`` spool (in the ``new``
subdirectory). The goal of ``gocept.cds.main.export`` is to export
these files to an FTP server that implements the Content Drehscheibe
(CDS) protocol. Those files that have been exported are moved to the
``cur`` directory in the spool.

In order to test our export procedure, we set up an FTP server first.

We create a temporary directory to hold the FTP files::

  >>> import tempfile
  >>> ftp_dir = tempfile.mkdtemp()

We set up the FTP server next::

  >>> from pyftpdlib import ftpserver

We don't want the FTP server to create all kinds logging messages::

  >>> def dummy_logger(msg):
  ...     pass
  >>> ftpserver.log = dummy_logger
  >>> ftpserver.logline = dummy_logger

We create an authorizer letting our test user write to ``ftp_dir``::

  >>> authorizer = ftpserver.DummyAuthorizer()
  >>> authorizer.add_user('test', 'testpw', ftp_dir, perm='elradfmw')

We complete the configuration::

  >>> ftp_handler = ftpserver.FTPHandler
  >>> ftp_handler.authorizer = authorizer
  >>> address = ('', 2001)
  >>> ftpd = ftpserver.FTPServer(address, ftp_handler)

Normally we'd start the ftp server with ``serve_forever``, but in our
tests we write a custom loop that we can actually shut down in the end
when we set ``stop_serving`` to ``True``. Ignore the following
implementation - it's not important to understand the rest of the
tests::

  >>> import asyncore
  >>> stop_serving = False
  >>> def run_ftp_server():
  ...     map = asyncore.socket_map
  ...     ftpd._map = ftpd.handler._map = map
  ...     while map or ftpserver._tasks:
  ...         if map:
  ...             asyncore.poll(1, map)
  ...         if ftpserver._tasks:
  ...             ftpserver._scheduler()
  ...         if stop_serving:
  ...             ftpd.close_all()

We now start the FTP server (in a separate thread, so the test can
continue)::

  >>> import threading
  >>> thread = threading.Thread(target=run_ftp_server)
  >>> thread.start()

We now create the ``gocept.filestore`` spool we want to export, again
in a temporary directory for testing purposes::

  >>> store_dir = tempfile.mkdtemp()
  >>> from gocept.filestore import filestore
  >>> fs = filestore.FileStore(store_dir)
  >>> fs.prepare()

We put two files in it::

  >>> a = fs.create('a-file')
  >>> a.write('This is the A file')
  >>> a.close()
  >>> b = fs.create('b-file')
  >>> b.write('This is the B file')
  >>> b.close()

We move those files to the ``new`` directory where our export logic
expects them::

  >>> fs.move('a-file', 'tmp', 'new')
  >>> fs.move('b-file', 'tmp', 'new')

Before we start exporting, we make sure we can track log messages::

  >>> import logging
  >>> import StringIO
  >>> logfile = StringIO.StringIO()
  >>> log_handler = logging.StreamHandler(logfile)
  >>> logging.root.addHandler(log_handler)
  >>> old_log_level = logging.root.level
  >>> logging.root.setLevel(logging.INFO)

Now we finally have enough set up to run the export procedure::
   
  >>> import zeit.cds.main
  >>> zeit.cds.main.export(
  ...     store_dir, 'localhost', 2001, 'test', 'testpw', '/')

We say here we want to export the information in the ``store_dir``
spool to the FTP server we just started on localhost, port 2001. The
user name to log in with is ``test`` and the password is
``testpw``. The directory we want to upload to is the FTP root.

This is the log of a successful export::

  >>> print logfile.getvalue()
  Connecting to CDS FTP server (host localhost, port 2001, user test, upload_dir /)
  Accessed filestore /tmp/...
  Creating lock file
  Lock file successfully created
  Uploaded file a-file
  Moved file a-file from 'new' to 'cur'
  Uploaded file b-file
  Moved file b-file from 'new' to 'cur'
  Removing lock file
  Lock file successfully removed
  Disconnected from CDS FTP server


 
Verify whether our upload procedure succeeded. We expect ``a-file``
and ``b-file`` to be in ``ftp_dir`` now:

  >>> import os
  >>> sorted(os.listdir(ftp_dir))
  ['a-file', 'b-file']

They also should have the right contents::

  >>> a = open(os.path.join(ftp_dir, 'a-file'), 'r')
  >>> a.read()
  'This is the A file'
  >>> a.close()
  >>> b = open(os.path.join(ftp_dir, 'b-file'), 'r')
  >>> b.read()
  'This is the B file'
  >>> b.close()

The spool we uploaded from will not have the files in the ``new``
directory anymore::

  >>> os.listdir(os.path.join(store_dir, 'new'))
  []

They have moved to the ``cur`` directory now::

  >>> sorted(os.listdir(os.path.join(store_dir, 'cur')))
  ['a-file', 'b-file']

Finally we need to shut down the FTP server::

  >>> stop_serving = True

We need to wait a little bit here to make sure things cleanly shut down::

  >>> import time
  >>> time.sleep(2)

Finally we can clean up the temporary directories::

  >>> import shutil
  >>> shutil.rmtree(ftp_dir)
  >>> shutil.rmtree(store_dir)

We return the logging situation back to normal::

  >>> logging.root.removeHandler(log_handler)
  >>> logging.root.setLevel(old_log_level)

